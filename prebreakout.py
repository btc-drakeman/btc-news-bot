# prebreakout.py
# -----------------------------------------
# "ÌÅ∞ Ï∫îÎì§Ïù¥ ÌÑ∞ÏßÄÍ∏∞ ÏßÅÏ†Ñ" ÏÇ¨Ï†ÑÏòàÏ∏°(Watch) ÏïåÎ¶º v6
# Ï°∞Í±¥: (5m ÏïïÏ∂ï) + (Î≥ºÎ•® lull‚Üíuptick) + (15m/5m Ï∂îÏÑ∏ ÏùºÏπò)
#     + (HH/LL Í∑ºÏ†ë) + (1m ÎØ∏ÏÑ∏ÌôïÏù∏)
# ÏßÑÏûÖ: ÏÑ†Ìñâ Limit(Î†àÎ≤®¬±0.1*ATR) + Fallback Stop-Limit
# -----------------------------------------

import time
import numpy as np
import pandas as pd
from analyzer import fetch_ohlcv
from notifier import send_telegram
from config import SYMBOLS, format_price, SL_PCT, TP_PCT

# ===== ÌååÎùºÎØ∏ÌÑ∞ =====
COOLDOWN_SEC       = 300        # Ïã¨Î≥º/Î∞©Ìñ•Î≥Ñ Ïø®Îã§Ïö¥
NEAR_TOL_BPS       = 25.0       # HH/LL Í∑ºÏ†ë ÌóàÏö©Ïπò(bps: 0.25%)
VOLUME_LULL_K      = 0.80       # lull: ÏßÅÏ†Ñ 3Î¥â ÌèâÍ∑† ‚â§ 0.8 * 30Î¥â Ï§ëÏïôÍ∞í
VOLUME_UPTICK_K    = 1.20       # uptick: ÎßàÏßÄÎßâ Î¥â ‚â• 1.2 * 30Î¥â Ï§ëÏïôÍ∞í
BBW_RATIO_MAX      = 0.60       # BBÌè≠(ÌòÑÏû¨) ‚â§ 50Î¥â Ï§ëÏïôÍ∞í * 0.60
ATR_RATIO_MAX      = 0.70       # ATR(ÌòÑÏû¨) ‚â§ 50Î¥â Ï§ëÏïôÍ∞í * 0.70
EMA_FAST           = 34         # 15m Ï∂îÏÑ∏ ÌåêÎã®Ïö©
EMA_SLOW           = 89
ONE_MIN_LOOKBACK   = 20         # 1m ÎØ∏ÏÑ∏ÌôïÏù∏Ïö© Î°§ÎßÅ
MICRO_VOL_MIN      = 1.00       # 1m ÎßàÏßÄÎßâ Î¥â Í±∞ÎûòÎüâ ‚â• med*1.00
PREENTRY_ATR_BUF   = 0.10       # ÏÑ†Ìñâ Î¶¨Î∞ã Î≤ÑÌçº: Î†àÎ≤® ¬± 0.10*ATR(5m)
FALLBACK_ATR_BUF   = 0.02       # Fallback Ïä§ÌÉë-Î¶¨Î∞ã: Î†àÎ≤® ¬± 0.02*ATR(5m)
FAILFAST_ATR_MOVE  = 0.20       # Ï≤¥Í≤∞ ÌõÑ 180Ï¥à ÎÇ¥ ¬±0.2*ATR ÏßÑÌñâ ÏóÜÏúºÎ©¥ Ïª∑ Í∂åÍ≥†
FAILFAST_DEADLINE  = 180        # Ï¥à
PB_MARGIN          = 2.0        # (Í∏∞Ï°¥ 1m ÏïïÎ†• Ï†êÏàò Ïö∞ÏúÑ ÏµúÏÜå Í≤©Ï∞® ÏÇ¨Ïö©)

_last_watch_ts = {}  # key="BTCUSDT:LONG" -> epoch

# ---------- Í≥µÏö© ÏßÄÌëú ----------
def ema(s: pd.Series, span: int):
    return s.ewm(span=span, adjust=False).mean()

def calc_atr(df: pd.DataFrame, period: int = 14):
    prev_close = df['close'].shift(1)
    tr = pd.concat([
        df['high'] - df['low'],
        (df['high'] - prev_close).abs(),
        (df['low'] - prev_close).abs()
    ], axis=1).max(axis=1)
    return tr.rolling(period).mean()

def bb_width(close: pd.Series, period: int = 20, k: float = 2.0):
    ma = close.rolling(period).mean()
    sd = close.rolling(period).std(ddof=0)
    upper = ma + k * sd
    lower = ma - k * sd
    return (upper - lower) / (ma + 1e-12)

# ---------- Î≥¥Ï°∞ ----------
def _cooldown_ok(symbol: str, direction: str, sec: int = COOLDOWN_SEC) -> bool:
    key = f"{symbol}:{direction}"
    now = time.time()
    ts = _last_watch_ts.get(key)
    if ts and now - ts < sec:
        return False
    _last_watch_ts[key] = now
    return True

def _levels_5m(df5: pd.DataFrame, lookback: int = 20):
    ref = df5.iloc[:-1]  # ÏôÑÎ£åÎ¥â Í∏∞Ï§Ä
    hh = float(ref['high'].rolling(lookback).max().iloc[-1])
    ll = float(ref['low'] .rolling(lookback).min().iloc[-1])
    px = float(df5['close'].iloc[-1])
    return hh, ll, px

def _near_bps(price: float, level: float, max_bps: float) -> (bool, float):
    bps = abs(price - level) / max(price, 1e-12) * 1e4
    return (bps <= max_bps), bps

# ---------- v6: Ï°∞Í±¥ Î¨∂Ïùå ----------
def _compression_ok(df5: pd.DataFrame) -> (bool, dict):
    atr = calc_atr(df5, 14)
    bbw = bb_width(df5['close'], 20, 2.0)

    med_bbw = bbw.rolling(50).median().iloc[-1]
    med_atr = atr.rolling(50).median().iloc[-1]
    bbw_ratio = float(bbw.iloc[-1] / (med_bbw + 1e-12))
    atr_ratio = float(atr.iloc[-1] / (med_atr + 1e-12))
    ok = (bbw_ratio <= BBW_RATIO_MAX) and (atr_ratio <= ATR_RATIO_MAX)
    return ok, {"bbw": float(bbw.iloc[-1]), "bbw_ratio": bbw_ratio, "atr_ratio": atr_ratio}

def _volume_lull_then_uptick(df5: pd.DataFrame) -> (bool, dict):
    vol = df5['volume']
    base = vol.rolling(30).median().iloc[-1]
    lull = (vol.iloc[-4:-1].mean() <= base * VOLUME_LULL_K)
    uptick = (vol.iloc[-1] >= base * VOLUME_UPTICK_K)
    return (lull and uptick), {
        "base_med": float(base),
        "last_over_med": float(vol.iloc[-1] / (base + 1e-12)),
        "lull_mean_over_med": float(vol.iloc[-4:-1].mean() / (base + 1e-12))
    }

def _trend_agree(df15: pd.DataFrame, df5: pd.DataFrame) -> (str, dict):
    e34_15 = float(ema(df15['close'], EMA_FAST).iloc[-1])
    e89_15 = float(ema(df15['close'], EMA_SLOW).iloc[-1])
    e34_5  = ema(df5['close'], EMA_FAST)
    slope5 = float(e34_5.iloc[-1] - e34_5.iloc[-4])

    if e34_15 > e89_15 and slope5 > 0:
        return "LONG", {"ema34_15": e34_15, "ema89_15": e89_15, "slope5": slope5}
    if e34_15 < e89_15 and slope5 < 0:
        return "SHORT", {"ema34_15": e34_15, "ema89_15": e89_15, "slope5": slope5}
    return "FLAT", {"ema34_15": e34_15, "ema89_15": e89_15, "slope5": slope5}

def _micro_confirm_1m(df1: pd.DataFrame, direction: str) -> (bool, dict):
    if len(df1) < ONE_MIN_LOOKBACK + 2:
        return False, {"reason": "insufficient_1m"}
    vol = df1['volume']
    med = float(vol.rolling(ONE_MIN_LOOKBACK).median().iloc[-1])
    v_ok = float(vol.iloc[-1]) >= med * MICRO_VOL_MIN
    hi_prev = float(df1['high'].iloc[-2])
    lo_prev = float(df1['low'].iloc[-2])
    c_last = float(df1['close'].iloc[-1])
    if direction == "LONG":
        p_ok = (c_last > hi_prev)
    elif direction == "SHORT":
        p_ok = (c_last < lo_prev)
    else:
        return False, {"reason": "flat_direction"}
    return (p_ok and v_ok), {"vol_last_over_med": (vol.iloc[-1] / (med + 1e-12)), "c_last": c_last, "hi_prev": hi_prev, "lo_prev": lo_prev}

# ---------- (Í∏∞Ï°¥) 1m ÏïïÎ†• Ï†êÏàò Ïû¨ÏÇ¨Ïö© ----------
def _pressure_direction_1m(df1: pd.DataFrame, lookback: int = 8):
    last = df1.tail(lookback).copy()
    if len(last) < lookback:
        return "NEUTRAL", 0.0, 0.0, {}

    hi, lo, op, cl, vol = last["high"], last["low"], last["open"], last["close"], last["volume"]
    span = (hi - lo).replace(0, np.nan)
    if span.isna().any():
        return "NEUTRAL", 0.0, 0.0, {}

    top_close_ratio = float(((cl - lo) / (span + 1e-12)).clip(0,1).mean())
    bot_close_ratio = float(((hi - cl) / (span + 1e-12)).clip(0,1).mean())
    hl_cnt = int((lo.diff() > 0).sum())
    lh_cnt = int((hi.diff() < 0).sum())
    up_vol   = float(vol[cl > op].sum())
    down_vol = float(vol[cl < op].sum())
    delta_proxy = float((np.sign(cl.diff().fillna(0)) * vol).sum())
    pv = (cl * vol)
    vwap = pv.cumsum() / (vol.cumsum() + 1e-12)
    above_vwap = int((cl > vwap).sum())
    below_vwap = int((cl < vwap).sum())
    hh_cnt = int((hi > hi.shift()).sum())
    ll_cnt = int((lo < lo.shift()).sum())

    score_long = 0.0
    score_long += 1.0 if top_close_ratio >= 0.70 else 0.0
    score_long += 1.0 if hl_cnt >= lookback//2 else 0.0
    score_long += 1.0 if up_vol > down_vol else 0.0
    score_long += 1.0 if delta_proxy > 0 else 0.0
    score_long += 0.5 if above_vwap >= lookback//2 else 0.0
    score_long += 0.5 if hh_cnt >= lookback//2 else 0.0

    score_short = 0.0
    score_short += 1.0 if bot_close_ratio >= 0.70 else 0.0
    score_short += 1.0 if lh_cnt >= lookback//2 else 0.0
    score_short += 1.0 if down_vol > up_vol else 0.0
    score_short += 1.0 if delta_proxy < 0 else 0.0
    score_short += 0.5 if below_vwap >= lookback//2 else 0.0
    score_short += 0.5 if ll_cnt >= lookback//2 else 0.0

    if score_long - score_short >= PB_MARGIN:
        direction = "LONG"
    elif score_short - score_long >= PB_MARGIN:
        direction = "SHORT"
    else:
        direction = "NEUTRAL"

    details = {
        "top_close_ratio": round(top_close_ratio, 3),
        "bot_close_ratio": round(bot_close_ratio, 3),
        "hl_cnt": hl_cnt, "lh_cnt": lh_cnt,
        "up_vol": round(up_vol, 3), "down_vol": round(down_vol, 3),
        "delta_proxy": round(delta_proxy, 3),
        "above_vwap": above_vwap, "below_vwap": below_vwap,
        "hh_cnt": hh_cnt, "ll_cnt": ll_cnt
    }
    return direction, float(score_long), float(score_short), details

def _build_msg(symbol: str, d: dict):
    emo = "üîº" if d["direction"] == "LONG" else "üîΩ"
    level_name = "HH20" if d["direction"] == "LONG" else "LL20"
    msg = (
        f"‚è≥ ÌîÑÎ¶¨-Î∏åÎ†àÏù¥ÌÅ¨ÏïÑÏõÉ v6(Ï§ÄÎπÑ): {symbol}\n"
        f"{emo} Î∞©Ìñ•: {d['direction']} | Ï†êÏàò: {d['score']}/6.0 | dist {d['dist_bps']:.1f}bp\n"
        f"üìç Î†àÎ≤®: {level_name} = {format_price(d['ref_level'])}\n"
        f"üì¶ ÏïïÏ∂ï: BBw_ratio={d['meta']['compression']['bbw_ratio']:.2f}, ATR_ratio={d['meta']['compression']['atr_ratio']:.2f}\n"
        f"üîä Î≥ºÎ•®: last/med={d['meta']['volume']['last_over_med']:.2f}, lull_mean/med={d['meta']['volume']['lull_mean_over_med']:.2f}\n"
        f"üß≠ Ï∂îÏÑ∏(15m/5m): EMA34 vs 89, slope5={d['meta']['trend']['slope5']:.2f}\n"
        f"üß© 1m ÌôïÏù∏: ok (last_over_med={d['meta']['micro']['vol_last_over_med']:.2f})\n"
        f"üí° ÏÑ†Ìñâ Limit: {format_price(d['pre_entry'])} | Fallback SLmt: {format_price(d['stop_entry'])}\n"
        f"üõë ÏòàÏãú SL: {format_price(d['sl'])} | üéØ TP1: {format_price(d['tp1'])} / TP2: {format_price(d['tp2'])}\n"
        f"‚è±Ô∏è Ï≤¥Í≤∞ ÌõÑ {FAILFAST_DEADLINE}Ï¥à ÎÇ¥ ¬±{int(FAILFAST_ATR_MOVE*100)}%*ATR ÏßÑÌñâ ÏóÜÏúºÎ©¥ Í∞ïÏ†ú Ï¢ÖÎ£å Í∂åÏû•"
    )
    return msg

# =============== Í≥µÍ∞ú Ìï®Ïàò(Î©îÏù∏ ÌõÖ) =================
def analyze_prebreakout(symbol: str) -> str | None:
    """
    Í∏∞Ï°¥ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Ïú†ÏßÄ.
    5m ÎßàÍ∞ê Ïù¥Î≤§Ìä∏ or 1Î∂Ñ Î£®ÌîÑÏóêÏÑú Ìò∏Ï∂ú Í∞ÄÎä•.
    """
    # Îç∞Ïù¥ÌÑ∞ Î°úÎìú
    df5  = fetch_ohlcv(symbol, "5m", 200)
    df15 = fetch_ohlcv(symbol, "15m", 200)
    df1  = fetch_ohlcv(symbol, "1m",  80)

    for df in (df5, df15, df1):
        for col in ['open','high','low','close','volume']:
            df[col] = df[col].astype(float)

    # 1) ÏïïÏ∂ï
    comp_ok, comp_meta = _compression_ok(df5)
    if not comp_ok:
        return None

    # 2) Î≥ºÎ•® Ìå®ÌÑ¥
    vol_ok, vol_meta = _volume_lull_then_uptick(df5)
    if not vol_ok:
        return None

    # 3) ÏÉÅÏúÑ Ï∂îÏÑ∏ ÎèôÏùò
    trend_dir, trend_meta = _trend_agree(df15, df5)
    if trend_dir == "FLAT":
        return None

    # 4) Î†àÎ≤® Í∑ºÏ†ë
    hh, ll, px = _levels_5m(df5, 20)
    if trend_dir == "LONG":
        near_ok, dist_bps = _near_bps(px, hh, NEAR_TOL_BPS)
        if not near_ok:
            return None
        direction = "LONG"
        ref_level = hh
    else:
        near_ok, dist_bps = _near_bps(px, ll, NEAR_TOL_BPS)
        if not near_ok:
            return None
        direction = "SHORT"
        ref_level = ll

    # 5) 1m ÎØ∏ÏÑ∏ÌôïÏù∏ + (Í∏∞Ï°¥ ÏïïÎ†• Ï†êÏàò) ÍµêÏ∞®Í≤ÄÏ¶ù
    micro_ok, micro_meta = _micro_confirm_1m(df1, direction)
    if not micro_ok:
        return None
    press_dir, score_l, score_s, press_meta = _pressure_direction_1m(df1, lookback=8)
    if press_dir != direction:
        return None

    # Ïø®Îã§Ïö¥
    if not _cooldown_ok(symbol, direction):
        return None

    # ÏóîÌä∏Î¶¨/Î¶¨Ïä§ÌÅ¨
    atr5 = float(calc_atr(df5, 14).iloc[-1])
    if direction == "LONG":
        pre_entry  = float(max(px, ref_level - PREENTRY_ATR_BUF * atr5))
        stop_entry = float(ref_level + FALLBACK_ATR_BUF * atr5)
        sl = float(ref_level - 1.0 * atr5)
        r  = pre_entry - sl
        tp1 = float(pre_entry + 1.8 * r)
        tp2 = float(pre_entry + 3.0 * r)
        level_name = "HH20"
    else:
        pre_entry  = float(min(px, ref_level + PREENTRY_ATR_BUF * atr5))
        stop_entry = float(ref_level - FALLBACK_ATR_BUF * atr5)
        sl = float(ref_level + 1.0 * atr5)
        r  = sl - pre_entry
        tp1 = float(pre_entry - 1.8 * r)
        tp2 = float(pre_entry - 3.0 * r)
        level_name = "LL20"

    # Ï†êÏàò(Í∞ÄÏ§ëÏπò): ÏïïÏ∂ï2 + Î≥ºÎ•®1.5 + Ï∂îÏÑ∏1 + Î†àÎ≤®Í∑ºÏ†ë0.5 + 1mÌôïÏù∏1 = 6
    score = 2.0 + 1.5 + 1.0 + (0.5 if dist_bps <= 12.0 else 0.25) + 1.0

    payload = {
        "direction": direction,
        "ref_level": float(ref_level),
        "dist_bps": float(dist_bps),
        "pre_entry": float(pre_entry),
        "stop_entry": float(stop_entry),
        "sl": float(sl),
        "tp1": float(tp1),
        "tp2": float(tp2),
        "score": float(round(score, 2)),
        "meta": {
            "compression": comp_meta,
            "volume": vol_meta,
            "trend": trend_meta,
            "micro": micro_meta,
            "press": press_meta,
        }
    }

    msg = _build_msg(symbol, payload)
    send_telegram(msg)
    return msg

def prebreakout_loop(sleep_sec: int = 60):
    """
    Í∏∞Ï°¥ Î£®ÌîÑ Ïú†ÏßÄ.
    WS Í∏∞Î∞òÏù¥Î©¥ 5m ÎßàÍ∞ê Ïù¥Î≤§Ìä∏ÏóêÏÑú analyze_prebreakout(symbol) Ìò∏Ï∂ú Í∂åÏû•.
    """
    print("üî≠ ÌîÑÎ¶¨-Î∏åÎ†àÏù¥ÌÅ¨ÏïÑÏõÉ Î£®ÌîÑ ÏãúÏûë")
    while True:
        try:
            for s in SYMBOLS:
                try:
                    analyze_prebreakout(s)
                except Exception as e:
                    print(f"‚ùå prebreakout({s}) Ïã§Ìå®: {e}")
            time.sleep(sleep_sec)
        except Exception as e:
            print("ÌîÑÎ¶¨Î∏åÎ†àÏù¥ÌÅ¨ Î£®ÌîÑ ÏóêÎü¨:", e)
            time.sleep(1)
